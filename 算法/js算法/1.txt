一、什么是算法？

  算法是指用来操作数据、解决程序问题的一组方法、对于一个问题、使用不容的算法得到的结果是一致的、但是所消耗的时间和空间是各不相同的

二、如何衡量一个算法的好坏

  描述算法的好坏一般会从两个维度、一个是时间复杂度、另外一个看空间复杂度

    时间复杂度：是指执行当前算法所消耗的时间
    空间复杂度：是指执行当前的算法所占用多少空间

  所以评价一个算法的好与坏不能单纯的从一个方向进行评价、鱼和熊掌不可兼得


  2.1 时间复杂度

    执行一遍我们的算法、记录时间得到的时间复杂度么？这种方式是可以的、但是有很多的弊端、比如在性能好的计算机上跑的结果和一般计算机上跑的结果可能不同、受到了了外界因素的干扰

    所以我们需要一种通用的方法来计算这个时间复杂度、不受机器性能等环境的影响

    我们使用大O符号的表示法 即 T(n) = O(f(n))

    🌰：
    
    for (let i = 0; i < n; i++) { // 执行 一颗粒的时间
      j = i // 执行n颗粒
      j++ // 执行n颗粒
    } // 符号忽略
    
    所以总的时间是 1 + n + n = 2n + 1
    T(n) = (1 + 2n) 约等于 O(n)
    在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。

    为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。


      2.1.1 常见的时间复杂度

        - 常数 O(1)
        - 对数O(logN)
        - 线性O(n)
        - 线性对数阶O(nlogN)
        - 平方阶O(n²)
        - 立方阶O(n³)
        - K次方阶O(n^k)
        - 指数阶(2^n)

        从上到下、执行的效率会越来越低


      2.1.2 O(1)
          只要没有循环、无论有多少条代码都是认为是O(1)
          int i = 1;
          int j = 2;
          ++i;
          j++;
          int m = i + j;
          
          上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。
        
      2.1.3 线性阶O(n)

        for(i=1; i<=n; ++i)
        {
          j = i;
          j++;
        }

      2.1.4 对数阶O(logN)
        int i = 1;
        while(i<n)
        {
          i = i * 2;
        }

      2.1.5 线性对数O(nlogN)

        for(m=1; m<n; m++)
        {
            i = 1;
            while(i<n)
            {
                i = i * 2;
            }
        }

      2.1.6 平方阶O(n²)

    for(x=1; i<=n; x++)
    {
      for(i=1; i<=n; i++)
        {
          j = i;
          j++;
        }
    }


  2.2 空间复杂度

  既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。

  2.2.1 空间复杂度 O(1)
  如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;


  2.2.2 空间复杂度 O(n)
  int[] m = new int[n]
  for(i=1; i<=n; ++i)
  {
    j = i;
    j++;
  }



  三、递归

    满足两个条件

      条件1、自己可以调用自己、需要满足这类条件的前提就是 子类和父类解决问题的方式是一致的

      条件2、有一个终止条件、可以跳出循环

    递归是基于队列来进行的

    能用队列来解决的问题都能用循环来解决、递归的写法让人可以更了解内容


  四、队列

    4.1 顺序队列

      使用数组来模拟队列、就是插入都是使用push向末尾插入、入队只能从shift来进读取 first in first out
      栈结构、先进后出、last in first out pop() 读取 用unshift来插入

  
  五、二分法
    时间复杂度 O(logN)、要求是一个升序的数组